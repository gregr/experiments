#lang racket/base
(provide
  s->list
  s-take
  s-append
  s-append-interleaving
  s-map
  solve1
  solve
  )

(define (s->list s) (s-take #f s))

(define (s-take n s)
  (cond
    ((or (eq? n 0) (null? s)) '())
    ((procedure? s)           (s-take n (s)))
    (else                     (cons (car s) (s-take (and n (- n 1)) (cdr s))))))

(define (s-append s1 s2)
  (let loop ((s1 s1))
    (cond
      ((null?      s1) s2)
      ((procedure? s1) (lambda () (loop (s1))))
      (else            (cons (car s1) (loop (cdr s1)))))))

(define (s-append-interleaving s1 s2)
  (let loop ((s1 s1) (s2 s2))
    (cond
      ((null?      s1) s2)
      ((procedure? s1) (lambda () (loop (if (procedure? s2) (s2) s2) s1)))
      (else            (cons (car s1) (loop s2 (cdr s1)))))))

(define (s-map f s)
  (let loop ((s s))
    (cond
      ((null?      s) '())
      ((procedure? s) (lambda () (loop (s))))
      (else           (cons (f (car s)) (loop (cdr s)))))))

;;;;;;;;;;;;;;;;;;;;;;;;
;;; Naive SAT solver ;;;
;;;;;;;;;;;;;;;;;;;;;;;;
(define (atom->literal-value literal atom-value)
  (* (if (< literal 0) -1 1) atom-value))
(define (literal->atom-value literal literal-value)
  ;; Coincidentally the same as atom->literal-value in this implementation
  (* (if (< literal 0) -1 1) literal-value))

(define (hash->vector x=>v)
  (let* ((len (+ (apply max 0 (hash-keys x=>v)) 1))
         (v*  (make-vector len 0)))
    (let loop ((i 0))
      (when (< i len)
        (vector-set! v* i (hash-ref x=>v i 0))
        (loop (+ i 1))))
    v*))

;(define (solve1 clause*)
;  (let loop ((c* clause*) (var=>val (hash)))
;    (if (null? c*)
;        (hash->vector var=>val)
;        (let ((c (car c*)) (c* (cdr c*)))
;          (let clause-loop ((literal* c) (var=>val var=>val))
;            (define (get literal)
;              (atom->literal-value literal (hash-ref var=>val (abs literal) 0)))
;            (define (put literal value)
;              (hash-set var=>val (abs literal) (literal->atom-value literal value)))
;            (and (not (null? literal*))
;                 (let ((l (car literal*)) (l* (cdr literal*)))
;                   (case (get l)
;                     ((-1) (clause-loop l* var=>val))
;                     ((1)  (loop c* var=>val))
;                     (else (or (loop c* (put l 1))
;                               (clause-loop l* (put l -1))))))))))))

;(define (solve clause*)
;  (let loop ((c* clause*) (var=>val (hash)))
;    (if (null? c*)
;        (list (hash->vector var=>val))
;        (let ((c (car c*)) (c* (cdr c*)))
;          (let clause-loop ((literal* c) (var=>val var=>val))
;            (define (get literal)
;              (atom->literal-value literal (hash-ref var=>val (abs literal) 0)))
;            (define (put literal value)
;              (hash-set var=>val (abs literal) (literal->atom-value literal value)))
;            (if (null? literal*)
;                '()
;                (let ((l (car literal*)) (l* (cdr literal*)))
;                  (case (get l)
;                    ((-1) (clause-loop l* var=>val))
;                    ((1)  (loop c* var=>val))
;                    (else (s-append (loop c* (put l 1))
;                                    (lambda () (clause-loop l* (put l -1)))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Otherwise naive SAT solver with special treatment for 2-literal clauses ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (literal->var lit) (abs lit))

;; This solver improves nqueens performance by almost 4000x, but still cannot solve sudoku
;; problems in a reasonable amount of time.
;(define (solve1 clause*)
;  (define (continue c* var=>val var=>2c*)
;    (define (get var=>val literal)
;      (atom->literal-value literal (hash-ref var=>val (literal->var literal) 0)))
;    (define (put var=>val l value)
;      (let loop ((c*.2     (hash-ref var=>2c* (literal->var l) '()))
;                 (var=>val (hash-set var=>val (literal->var l) (literal->atom-value l value))))
;        (and var=>val
;             (if (null? c*.2)
;                 var=>val
;                 (let* ((clause (car  c*.2))
;                        (l1     (car  clause))
;                        (l2     (cadr clause)))
;                   (loop (cdr c*.2)
;                         (if (= (atom->literal-value l1 (literal->atom-value l value)) 1)
;                             var=>val
;                             (case (get var=>val l2)
;                               ;((-1) #f)
;                               ((-1) var=>val)
;                               ((1)  var=>val)
;                               (else (put var=>val l2 1))))))))))
;    (let loop ((c* clause*) (var=>val (hash)))
;      (if (null? c*)
;          (hash->vector var=>val)
;          (let ((c (car c*)) (c* (cdr c*)))
;            (let clause-loop ((literal* c) (var=>val var=>val))
;              (and (not (null? literal*))
;                   (let ((l (car literal*)) (l* (cdr literal*)))
;                     (case (get var=>val l)
;                       ((-1) (clause-loop l* var=>val))
;                       ((1)  (loop c* var=>val))
;                       (else (or (let ((var=>val (put var=>val l 1)))
;                                   (and var=>val (loop c* var=>val)))
;                                 (let ((var=>val (put var=>val l -1)))
;                                   (and var=>val (clause-loop l* var=>val)))))))))))))
;  (let loop ((c* clause*) (c*.long '()) (c*.2 '()) (var=>val (hash)) (var=>2c* (hash)))
;    (define (put literal value)
;      (hash-set var=>val (literal->var literal) (literal->atom-value literal value)))
;    (if (null? c*)
;        (continue (append (reverse c*.long) (reverse c*.2)) var=>val var=>2c*)
;        (let ((c (car c*)) (c* (cdr c*)))
;          (case (length c)
;            ((0)  #f)
;            ((1)  (loop c* c*.long c*.2 (put (car c) 1) var=>2c*))
;            ((2)  (loop c* c*.long (cons c c*.2) var=>val
;                        (hash-update (hash-update var=>2c* (literal->var (car c))
;                                                  (lambda (c*) (cons c c*))
;                                                  '())
;                                     (literal->var (cadr c))
;                                     (lambda (c*) (cons (reverse c) c*))
;                                     '())))
;            (else (loop c* (cons c c*.long) c*.2 var=>val var=>2c*)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Basic SAT solver with 2-watched clauses and unit propagation ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (literal-transform l val) (* (if (< l 0) -1 1) val))
(define (get x=>v l) (literal-transform l (hash-ref x=>v (literal->var l) 0)))
(define ((watch!/boxes &var=>i*+ &var=>i*-) l i)
  (let ((var (literal->var l)))
    (if (< l 0)
        (set-box! &var=>i*- (hash-update (unbox &var=>i*-) var (lambda (i*) (cons i i*)) '()))
        (set-box! &var=>i*+ (hash-update (unbox &var=>i*+) var (lambda (i*) (cons i i*)) '())))))

(define (solve1 clause*)
  (define (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val)
    (define (force-value l val k)
      (define watch! (watch!/boxes &var=>i*+ &var=>i*-))
      (let* ((var (literal->var l)) (val (literal-transform l val)))
        (set-box! &var=>val (hash-set (unbox &var=>val) var val))
        (let loop ((i* (hash-ref (unbox (if (< val 0) &var=>i*+ &var=>i*-)) var '())))
          (if (null? i*)
              (k)
              (let* ((i  (car i*))
                     (l* (hash-ref (unbox &i=>l*) i))
                     (l1 (car l*))
                     (l2 (cadr l*))
                     (l0 (if (eq? var (literal->var l1)) l2 l1))
                     (v0 (get (unbox &var=>val) l0)))
                (if (= v0 1)
                    (loop (cdr i*))
                    (let loop-next ((l0* (cddr l*)))
                      (if (null? l0*)
                          (and (= v0 0) (force-value l0 1 (lambda () (loop (cdr i*)))))
                          (case (get (unbox &var=>val) (car l0*))
                            ((-1) (loop-next (cdr l0*)))
                            ((1)  (loop (cdr i*)))
                            (else (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l0 l0*)))
                                  (watch! (car l0*) i)
                                  (loop (cdr i*))))))))))))
    force-value)
  (define (continue i=>l* var=>i*+ var=>i*- var=>val)
    (let loop ((i 0) (i=>l* i=>l*) (var=>i*+ var=>i*+) (var=>i*- var=>i*-) (var=>val var=>val))
      (define (force-value/branch l val)
        (let ((&i=>l* (box i=>l*)) (&var=>i*+ (box var=>i*+)) (&var=>i*- (box var=>i*-)) (&var=>val (box var=>val)))
          (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val))
          (force-value l val (lambda () (loop i (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-)
                                              (unbox &var=>val))))))
      (let ((l* (hash-ref i=>l* i #f)))
        (if l*
            (if (ormap (lambda (l) (= (get var=>val l) 1)) l*)
                (loop (+ i 1) i=>l* var=>i*+ var=>i*- var=>val)
                (let loop-unassigned ((l* l*))
                  (and (not (null? l*))
                       (let ((l0 (car l*)))
                         (if (= (get var=>val l0) 0)
                             (or (force-value/branch l0 1) (force-value/branch l0 -1))
                             (loop-unassigned (cdr l*)))))))
            (if (= (hash-count i=>l*) i)
                (hash->vector var=>val)
                (error "hole in clauses" i (hash-count i=>l*)))))))
  (let ((&i=>l* (box (hash))) (&var=>i*+ (box (hash))) (&var=>i*- (box (hash))) (&var=>val (box (hash))))
    (define (force-true/k l k) (force-value l 1 k))
    (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val))
    (define watch! (watch!/boxes &var=>i*+ &var=>i*-))
    (let loop ((i 0) (clause* clause*))
      (if (null? clause*)
          (continue (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-) (unbox &var=>val))
          (let ((l* (car clause*)))
            (and (not (null? l*))
                 (let loop-l1 ((l1 (car l*)) (l* (cdr l*)))
                   (case (get (unbox &var=>val) l1)
                     ((-1) (and (not (null? l*)) (loop-l1 (car l*) (cdr l*))))
                     ((1)  (loop i (cdr clause*)))
                     (else (define (force-true l) (force-true/k l (lambda () (loop i (cdr clause*)))))
                           (if (null? l*)
                               (force-true l1)
                               (let loop-l2 ((l2 (car l*)) (l* (cdr l*)))
                                 (case (get (unbox &var=>val) l2)
                                   ((-1) (if (null? l*)
                                             (force-true l1)
                                             (loop-l2 (car l*) (cdr l*))))
                                   ((1)  (loop i (cdr clause*)))
                                   (else (watch! l1 i)
                                         (watch! l2 i)
                                         (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l1 (cons l2 l*))))
                                         (loop (+ i 1) (cdr clause*)))))))))))))))

(define (solve clause*)
  (define (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val)
    (define (force-value l val k)
      (define watch! (watch!/boxes &var=>i*+ &var=>i*-))
      (let* ((var (literal->var l)) (val (literal-transform l val)))
        (set-box! &var=>val (hash-set (unbox &var=>val) var val))
        (let loop ((i* (hash-ref (unbox (if (< val 0) &var=>i*+ &var=>i*-)) var '())))
          (if (null? i*)
              (k)
              (let* ((i  (car i*))
                     (l* (hash-ref (unbox &i=>l*) i))
                     (l1 (car l*))
                     (l2 (cadr l*))
                     (l0 (if (eq? var (literal->var l1)) l2 l1))
                     (v0 (get (unbox &var=>val) l0)))
                (if (= v0 1)
                    (loop (cdr i*))
                    (let loop-next ((l0* (cddr l*)))
                      (if (null? l0*)
                          (if (= v0 0)
                              (force-value l0 1 (lambda () (loop (cdr i*))))
                              '())
                          (case (get (unbox &var=>val) (car l0*))
                            ((-1) (loop-next (cdr l0*)))
                            ((1)  (loop (cdr i*)))
                            (else (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l0 l0*)))
                                  (watch! (car l0*) i)
                                  (loop (cdr i*))))))))))))
    force-value)
  (define (continue i=>l* var=>i*+ var=>i*- var=>val)
    (let loop ((i 0) (i=>l* i=>l*) (var=>i*+ var=>i*+) (var=>i*- var=>i*-) (var=>val var=>val))
      (define (force-value/branch l val)
        (let ((&i=>l* (box i=>l*)) (&var=>i*+ (box var=>i*+)) (&var=>i*- (box var=>i*-)) (&var=>val (box var=>val)))
          (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val))
          (force-value l val (lambda () (loop i (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-)
                                              (unbox &var=>val))))))
      (let ((l* (hash-ref i=>l* i #f)))
        (if l*
            (if (ormap (lambda (l) (= (get var=>val l) 1)) l*)
                (loop (+ i 1) i=>l* var=>i*+ var=>i*- var=>val)
                (let loop-unassigned ((l* l*))
                  (if (null? l*)
                      '()
                      (let ((l0 (car l*)))
                        (if (= (get var=>val l0) 0)
                            ;; No significant performance difference with s-append-interleaving on
                            ;; the current benchmarks.
                            (s-append (force-value/branch l0 1) (force-value/branch l0 -1))
                            (loop-unassigned (cdr l*)))))))
            (if (= (hash-count i=>l*) i)
                (list (hash->vector var=>val))
                (error "hole in clauses" i (hash-count i=>l*)))))))
  (let ((&i=>l* (box (hash))) (&var=>i*+ (box (hash))) (&var=>i*- (box (hash))) (&var=>val (box (hash))))
    (define (force-true/k l k) (force-value l 1 k))
    (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>val))
    (define watch! (watch!/boxes &var=>i*+ &var=>i*-))
    (let loop ((i 0) (clause* clause*))
      (if (null? clause*)
          (continue (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-) (unbox &var=>val))
          (let ((l* (car clause*)))
            (if (null? l*)
                '()
                (let loop-l1 ((l1 (car l*)) (l* (cdr l*)))
                  (case (get (unbox &var=>val) l1)
                    ((-1) (if (null? l*) '() (loop-l1 (car l*) (cdr l*))))
                    ((1)  (loop i (cdr clause*)))
                    (else (define (force-true l) (force-true/k l (lambda () (loop i (cdr clause*)))))
                          (if (null? l*)
                              (force-true l1)
                              (let loop-l2 ((l2 (car l*)) (l* (cdr l*)))
                                (case (get (unbox &var=>val) l2)
                                  ((-1) (if (null? l*)
                                            (force-true l1)
                                            (loop-l2 (car l*) (cdr l*))))
                                  ((1)  (loop i (cdr clause*)))
                                  (else (watch! l1 i)
                                        (watch! l2 i)
                                        (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l1 (cons l2 l*))))
                                        (loop (+ i 1) (cdr clause*)))))))))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Branch on variables chosen by maximum occurrences in clauses of minimal size (MOMS) heuristic ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (neg l) (- l))

;; This implementation performs significantly worse than the previous one.  The problem is not in
;; the additional counting overhead.  We can tell that this is the case because if you leave the
;; counting plumbing in, but disable choice-making based on the counts, our performance is still
;; about as good as it was before.
;; The decisions we are making are worse than choosing arbitrarily based on the order of the given
;; clauses.
;(define (solve1 clause*)
;  (define ((watch!/boxes &var=>i*+ &var=>i*- &var=>count+ &var=>count-) l i count?)
;    (let ((var         (literal->var l))
;          (&var=>i*    (if (< l 0) &var=>i*-    &var=>i*+))
;          (&var=>count (if (< l 0) &var=>count- &var=>count+)))
;      (set-box! &var=>i*    (hash-update (unbox &var=>i*)    var (lambda (i*) (cons i i*)) '()))
;      (when count?
;        (set-box! &var=>count (hash-update (unbox &var=>count) var (lambda (n) (+ n 1)) 0)))))
;  (define (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>count+ &var=>count- &var=>val)
;    (define (force-value l val k)
;      (define watch! (watch!/boxes &var=>i*+ &var=>i*- &var=>count+ &var=>count-))
;      (let* ((var (literal->var l)) (val (literal-transform l val)))
;        (set-box! &var=>val    (hash-set    (unbox &var=>val)    var val))
;        (set-box! &var=>count+ (hash-remove (unbox &var=>count+) var))
;        (set-box! &var=>count- (hash-remove (unbox &var=>count-) var))
;        (let loop ((i* (hash-ref (unbox (if (< val 0) &var=>i*+ &var=>i*-)) var '())))
;          (if (null? i*)
;              (k)
;              (let* ((i  (car i*))
;                     (l* (hash-ref (unbox &i=>l*) i))
;                     (l1 (car l*))
;                     (l2 (cadr l*))
;                     (l0 (if (eq? var (literal->var l1)) l2 l1))
;                     (v0 (get (unbox &var=>val) l0)))
;                (if (= v0 1)
;                    (loop (cdr i*))
;                    (let loop-next ((l0* (cddr l*)))
;                      (if (null? l0*)
;                          (and (= v0 0) (force-value l0 1 (lambda () (loop (cdr i*)))))
;                          (case (get (unbox &var=>val) (car l0*))
;                            ((-1) (loop-next (cdr l0*)))
;                            ((1)  (loop (cdr i*)))
;                            (else (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l0 l0*)))
;                                  (watch! (car l0*) i (null? (cdr l0*)))
;                                  (loop (cdr i*))))))))))))
;    force-value)
;  (define (continue i=>l* var=>i*+ var=>i*- var=>count+ var=>count- var=>val)
;    (let loop ((i 0) (i=>l* i=>l*) (var=>i*+ var=>i*+) (var=>i*- var=>i*-) (var=>count+ var=>count+) (var=>count- var=>count-) (var=>val var=>val))
;      (define (force-value/branch l val)
;        (let ((&i=>l* (box i=>l*)) (&var=>i*+ (box var=>i*+)) (&var=>i*- (box var=>i*-)) (&var=>count+ (box var=>count+)) (&var=>count- (box var=>count-)) (&var=>val (box var=>val)))
;          (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>count+ &var=>count- &var=>val))
;          (force-value l val (lambda () (loop i (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-) (unbox &var=>count+) (unbox &var=>count-) (unbox &var=>val))))))
;      (let ((max-+? #f) (max-count 0) (max-var #f))
;        (hash-for-each var=>count+ (lambda (var count)
;                                     (let ((count count))
;                                     ;; Both individual and summed counts perform badly.
;                                     ;(let ((count (+ (hash-ref var=>count- var 0) count)))
;                                       (when (< max-count count)
;                                         (set! max-count count)
;                                         (set! max-var   var)
;                                         (set! max-+?    #t)))))
;        (hash-for-each var=>count- (lambda (var count)
;                                     (let ((count count))
;                                     ;; Both individual and summed counts perform badly.
;                                     ;(let ((count (+ (hash-ref var=>count+ var 0) count)))
;                                       (when (< max-count count)
;                                         (set! max-count count)
;                                         (set! max-var   var)
;                                         (set! max-+?    #t)))))
;        (if ;#f  ; Use this instead to disable choice-making while leaving in all the counting and analysis overhead.
;            (< 0 max-count)
;            ;; Both of these orders perform badly.
;            (let ((l (if max-+? (neg max-var) max-var)))
;            ;(let ((l (if max-+? max-var (neg max-var))))
;              (or (force-value/branch l 1) (force-value/branch l -1)))
;            (let ((l* (hash-ref i=>l* i #f)))
;              (if l*
;                  (if (ormap (lambda (l) (= (get var=>val l) 1)) l*)
;                      (loop (+ i 1) i=>l* var=>i*+ var=>i*- var=>count+ var=>count- var=>val)
;                      (let loop-unassigned ((l* l*))
;                        (and (not (null? l*))
;                             (let ((l0 (car l*)))
;                               (if (= (get var=>val l0) 0)
;                                   (or (force-value/branch l0 1) (force-value/branch l0 -1))
;                                   (loop-unassigned (cdr l*)))))))
;                  (if (= (hash-count i=>l*) i)
;                      (hash->vector var=>val)
;                      (error "hole in clauses" i (hash-count i=>l*)))))))))
;  (let ((&i=>l* (box (hash))) (&var=>i*+ (box (hash))) (&var=>i*- (box (hash))) (&var=>count+ (box (hash))) (&var=>count- (box (hash))) (&var=>val (box (hash))))
;    (define (force-true/k l k) (force-value l 1 k))
;    (define force-value (force-value/boxes &i=>l* &var=>i*+ &var=>i*- &var=>count+ &var=>count- &var=>val))
;    (define watch! (watch!/boxes &var=>i*+ &var=>i*- &var=>count+ &var=>count-))
;    (let loop ((i 0) (clause* clause*))
;      (if (null? clause*)
;          (continue (unbox &i=>l*) (unbox &var=>i*+) (unbox &var=>i*-) (unbox &var=>count+) (unbox &var=>count-) (unbox &var=>val))
;          (let ((l* (car clause*)))
;            (and (not (null? l*))
;                 (let loop-l1 ((l1 (car l*)) (l* (cdr l*)))
;                   (case (get (unbox &var=>val) l1)
;                     ((-1) (and (not (null? l*)) (loop-l1 (car l*) (cdr l*))))
;                     ((1)  (loop i (cdr clause*)))
;                     (else (define (force-true l) (force-true/k l (lambda () (loop i (cdr clause*)))))
;                           (if (null? l*)
;                               (force-true l1)
;                               (let loop-l2 ((l2 (car l*)) (l* (cdr l*)))
;                                 (case (get (unbox &var=>val) l2)
;                                   ((-1) (if (null? l*)
;                                             (force-true l1)
;                                             (loop-l2 (car l*) (cdr l*))))
;                                   ((1)  (loop i (cdr clause*)))
;                                   (else (let ((count? (null? l*)))
;                                           (watch! l1 i count?)
;                                           (watch! l2 i count?)
;                                           (set-box! &i=>l* (hash-set (unbox &i=>l*) i (cons l1 (cons l2 l*))))
;                                           (loop (+ i 1) (cdr clause*))))))))))))))))
