#lang racket/base
(provide
  sudoku-solve1
  sudoku-solve
  )
(require "sat1.rkt" racket/list racket/pretty)

;;; Sudoku representation where each x is an integer in 1..9:
;;; ((x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x)
;;;  (x x x x x x x x x))

;; SAT representation:
;; - one propositional variable for each pair of cell and possible numeric value
;;   - (* 9 9 9) = 729 variables for N=9
(define N 9)
(define (neg x)                         (* -1 x))
(define (cell-value->var row col value) (+ (* 100 row) (* 10 col) value))

(define (make-sudoku-sat-clause* row*)
  (let ((group*
         (append
          (let loop ((row 1))
            (if (<= row N)
                (cons (let loop ((col 1))
                        (if (<= col N)
                            (cons (cons row col) (loop (+ col 1)))
                            '()))
                      (loop (+ row 1)))
                '()))
          (let loop ((col 1))
            (if (<= col N)
                (cons (let loop ((row 1))
                        (if (<= row N)
                            (cons (cons row col) (loop (+ row 1)))
                            '()))
                      (loop (+ col 1)))
                '()))
          (let loop ((row0 1))
            (if (<= row0 N)
                (append
                 (let loop ((col0 1))
                   (if (<= col0 N)
                       (cons
                        (list
                         (cons row0       col0) (cons row0       (+ col0 1)) (cons row0       (+ col0 2))
                         (cons (+ row0 1) col0) (cons (+ row0 1) (+ col0 1)) (cons (+ row0 1) (+ col0 2))
                         (cons (+ row0 2) col0) (cons (+ row0 2) (+ col0 1)) (cons (+ row0 2) (+ col0 2)))
                        (loop (+ col0 3)))
                       '()))
                 (loop (+ row0 3)))
                '())))))

    (append
     ;; - one unit clause per known cell value in the initial position
     (let loop ((row 1) (row* row*))
       (if (<= row N)
           (append (let loop ((col 1) (col* (car row*)))
                     (if (<= col N)
                         (let ((value   (car col*))
                               (clause* (loop (+ col 1) (cdr col*))))
                           (if (< 0 value)
                               (cons (list (cell-value->var row col value)) clause*)
                               clause*))
                         '()))
                   (loop (+ row 1) (cdr row*)))
           '()))
     ;; - for each pair of cell and value
     ;;   - for each other value
     ;;     - one clause to assert that if the cell has that value, then it does not have the other value
     (let loop ((row 1))
       (if (<= row N)
           (append
            (let loop ((col 1))
              (if (<= col N)
                  (append
                   (let loop ((value 1))
                     (if (< value N)
                         (let ((not-var (neg (cell-value->var row col value))))
                           (append (map (lambda (co-value)
                                          (list not-var (neg (cell-value->var row col co-value))))
                                        (range (+ value 1) (+ N 1)))
                                   (loop (+ value 1))))
                         '()))
                   (loop (+ col 1)))
                  '()))
            (loop (+ row 1)))
           '()))
     ;; - for each cell
     ;;   - one clause to assert the cell has at least one of the values
     (let loop ((row 1))
       (if (<= row N)
           (append (let loop ((col 1))
                     (if (<= col N)
                         (cons (let loop ((value 1))
                                 (if (<= value N)
                                     (cons (cell-value->var row col value)
                                           (loop (+ value 1)))
                                     '()))
                               (loop (+ col 1)))
                         '()))
                   (loop (+ row 1)))
           '()))
     ;; With this representation we will have 3240 clauses before considering initial cell values.
     ;; These clauses are correct, but the feedback they provide is too indirect.
     ;; - for each group (row, column, or block)
     ;;   - for each value
     ;;     - one clause asserting that at least one cell in the group has that value
     ;(let loop ((group* group*))
     ;  (if (null? group*)
     ;      '()
     ;      (append
     ;       (let loop ((value 1))
     ;         (if (<= value N)
     ;             (cons (let loop ((cell* (car group*)))
     ;                     (if (null? cell*)
     ;                         '()
     ;                         (let* ((cell (car cell*))
     ;                                (row  (car cell))
     ;                                (col  (cdr cell)))
     ;                           (cons (cell-value->var row col value) (loop (cdr cell*))))))
     ;                   (loop (+ value 1)))
     ;             '()))
     ;       (loop (cdr group*)))))
     ;; With this representation we will have 11745 clauses before considering initial cell values.
     ;; Instead of the above, these clauses are more direct, catching bad choices more quickly.
     ;; - "all cells in the group are different"
     ;; - we can say this as "if a cell has a value, no other cell has that value"
     ;; - for each group (row, column, or block)
     ;;   - for each value
     ;;     - for each cell in the group
     ;;       - for each co-cell in the group
     ;;         - if the cell has the value, then the co-cell does not have the value
     (let loop ((group* group*))
       (if (null? group*)
           '()
           (append
            (let loop ((value 1))
              (if (<= value N)
                  (append
                   (let ((cell* (car group*)))
                     (let loop ((cell (car cell*)) (cell* (cdr cell*)))
                       (if (null? cell*)
                           '()
                           (let* ((row     (car cell))
                                  (col     (cdr cell))
                                  (not-var (neg (cell-value->var row col value))))
                             (append
                              (let loop ((cell* cell*))
                                (if (null? cell*)
                                    '()
                                    (let* ((co-cell (car cell*))
                                           (row     (car co-cell))
                                           (col     (cdr co-cell)))
                                      (cons (list not-var (neg (cell-value->var row col value)))
                                            (loop (cdr cell*))))))
                              (loop (car cell*) (cdr cell*)))))))
                   (loop (+ value 1)))
                  '()))
            (loop (cdr group*))))))))

(define (sudoku-reify v=>x)
  (let loop-row ((row 1))
    (if (<= row N)
        (cons (let loop-col ((col 1))
                (if (<= col N)
                    (cons (let loop-val ((value 1))
                            (if (<= value N)
                                (case (vector-ref v=>x (cell-value->var row col value))
                                  ((-1) (loop-val (+ value 1)))
                                  ((1)  value)
                                  (else (error "unassigned cell-value" row col value v=>x)))
                                (error "cell has no value" row col)))
                          (loop-col (+ col 1)))
                    '()))
              (loop-row (+ row 1)))
        '())))

(define (sudoku-solve1 row*)
  (sudoku-reify (solve1 (make-sudoku-sat-clause* row*))))

(define (sudoku-solve row*)
  (s-map sudoku-reify (solve (make-sudoku-sat-clause* row*))))

;; The second naive SAT solver on really-easy.0:
;cpu time: 8 real time: 8 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
(define really-easy.0 '((4 6 9 8 3 2 1 0 7)
                        (7 3 5 1 9 6 2 8 4)
                        (2 8 1 7 4 0 3 9 6)
                        (9 2 0 3 7 8 4 1 5)
                        (1 5 8 4 2 9 7 0 3)
                        (3 4 0 5 6 1 9 2 8)
                        (5 1 3 0 8 4 6 7 2)
                        (6 9 4 2 5 7 0 3 1)
                        (0 7 2 6 1 3 5 4 9)))
;cpu time: 1 real time: 1 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

;; The second naive SAT solver on really-easy.1
;cpu time: 48253 real time: 51009 gc time: 25
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
(define really-easy.1 '((0 6 0 8 3 2 1 0 7)
                        (0 3 5 1 0 0 2 8 4)
                        (2 8 1 7 4 5 0 9 6)
                        (9 2 0 3 7 0 4 0 0)
                        (1 0 8 0 2 9 7 6 0)
                        (0 4 0 5 0 1 0 2 8)
                        (5 0 3 0 8 4 0 7 2)
                        (6 0 4 2 5 7 0 3 1)
                        (0 7 2 0 1 3 5 4 9)))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

;; The second naive SAT solver still takes too long to solve really-easy.2.
(define really-easy.2 '((0 6 0 0 3 2 0 5 7)
                        (0 0 5 1 0 0 2 0 0)
                        (2 8 1 7 4 5 0 9 6)
                        (0 0 0 0 7 0 0 0 0)
                        (0 0 8 0 0 9 7 6 0)
                        (0 4 0 5 0 1 0 0 8)
                        (5 0 3 9 8 4 0 7 0)
                        (6 0 4 0 5 7 0 3 1)
                        (0 0 2 0 1 0 0 0 9)))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

(define really-easy.3 '((0 6 0 0 3 2 0 5 7)
                        (0 0 5 1 0 0 0 0 0)
                        (2 8 1 7 4 5 0 9 6)
                        (0 0 0 0 7 0 0 0 0)
                        (0 0 8 0 0 9 7 6 0)
                        (0 4 0 5 0 1 0 0 8)
                        (5 0 3 9 8 4 0 7 0)
                        (6 0 4 0 5 7 0 3 1)
                        (0 0 2 0 1 0 0 0 9)))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

(define really-easy.4 '((0 0 0 0 3 2 0 5 7)
                        (0 0 5 1 0 0 2 0 0)
                        (2 8 1 7 4 5 0 9 6)
                        (0 0 0 0 7 0 0 0 0)
                        (0 0 8 0 0 9 7 6 0)
                        (0 4 0 5 0 1 0 0 8)
                        (5 0 3 9 8 4 0 7 0)
                        (6 0 4 0 5 7 0 3 1)
                        (0 0 2 0 1 0 0 0 9)))
;cpu time: 4 real time: 4 gc time: 1
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

(define easy.1 '((0 0 0 0 3 2 0 5 7)
                 (0 0 5 1 0 0 0 0 0)
                 (2 8 1 7 4 5 0 9 6)
                 (0 0 0 0 7 0 0 0 0)
                 (0 0 8 0 0 9 7 6 0)
                 (0 4 0 5 0 1 0 0 8)
                 (5 0 3 9 8 4 0 7 0)
                 (6 0 4 0 5 7 0 3 1)
                 (0 0 2 0 1 0 0 0 9)))
;cpu time: 3 real time: 3 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))

(define easy.2 '((0 3 0 0 4 0 0 0 7)
                 (0 4 0 0 2 1 3 9 0)
                 (1 9 0 0 0 0 0 8 0)
                 (3 7 8 2 0 0 0 1 0)
                 (4 0 0 5 1 8 7 0 0)
                 (0 0 1 4 0 0 0 2 0)
                 (0 1 3 7 0 0 0 4 0)
                 (2 5 7 9 0 0 8 3 0)
                 (9 0 0 0 0 3 0 7 2)))
;cpu time: 4 real time: 4 gc time: 1
;((8 3 2 6 4 9 1 5 7)
; (7 4 5 8 2 1 3 9 6)
; (1 9 6 3 7 5 2 8 4)
; (3 7 8 2 9 6 4 1 5)
; (4 2 9 5 1 8 7 6 3)
; (5 6 1 4 3 7 9 2 8)
; (6 1 3 7 8 2 5 4 9)
; (2 5 7 9 6 4 8 3 1)
; (9 8 4 1 5 3 6 7 2))

(define medium.1 '((0 0 0 0 0 7 9 1 0)
                   (0 0 7 0 0 4 6 0 0)
                   (5 0 8 9 0 3 4 0 0)
                   (9 2 0 3 0 5 0 0 0)
                   (8 0 1 7 2 0 0 0 0)
                   (4 0 0 0 0 1 2 5 0)
                   (6 0 0 0 0 0 0 0 0)
                   (0 0 0 1 0 0 0 0 8)
                   (2 1 9 0 3 0 0 0 0)))
;cpu time: 2 real time: 3 gc time: 0
;((3 4 2 6 8 7 9 1 5)
; (1 9 7 2 5 4 6 8 3)
; (5 6 8 9 1 3 4 2 7)
; (9 2 6 3 4 5 8 7 1)
; (8 5 1 7 2 6 3 4 9)
; (4 7 3 8 9 1 2 5 6)
; (6 8 5 4 7 9 1 3 2)
; (7 3 4 1 6 2 5 9 8)
; (2 1 9 5 3 8 7 6 4))

(define medium.2 '((7 0 4 0 0 0 6 0 0)
                   (6 0 0 0 9 8 0 0 0)
                   (0 0 0 0 0 0 2 0 9)
                   (1 0 0 4 2 0 5 0 8)
                   (0 7 0 0 0 0 0 4 2)
                   (0 0 2 6 0 0 1 0 0)
                   (4 0 0 8 0 1 0 2 0)
                   (2 6 0 3 4 9 0 5 0)
                   (0 0 0 0 0 0 0 7 0)))
;cpu time: 3 real time: 3 gc time: 0
;((7 9 4 1 3 2 6 8 5)
; (6 2 1 5 9 8 7 3 4)
; (3 8 5 7 6 4 2 1 9)
; (1 3 9 4 2 7 5 6 8)
; (8 7 6 9 1 5 3 4 2)
; (5 4 2 6 8 3 1 9 7)
; (4 5 3 8 7 1 9 2 6)
; (2 6 7 3 4 9 8 5 1)
; (9 1 8 2 5 6 4 7 3))

(define grid.50 '((3 0 0 2 0 0 0 0 0)
                  (0 0 0 1 0 7 0 0 0)
                  (7 0 6 0 3 0 5 0 0)
                  (0 7 0 0 0 9 0 8 0)
                  (9 0 0 0 2 0 0 0 4)
                  (0 1 0 8 0 0 0 5 0)
                  (0 0 9 0 4 0 3 0 1)
                  (0 0 0 7 0 2 0 0 0)
                  (0 0 0 0 0 8 0 0 6)))
;cpu time: 4 real time: 5 gc time: 0
;((3 5 1 2 8 6 4 9 7)
; (4 9 2 1 5 7 6 3 8)
; (7 8 6 9 3 4 5 1 2)
; (2 7 5 4 6 9 1 8 3)
; (9 3 8 5 2 1 7 6 4)
; (6 1 4 8 7 3 2 5 9)
; (8 2 9 6 4 5 3 7 1)
; (1 6 3 7 9 2 8 4 5)
; (5 4 7 3 1 8 9 2 6))

(define hard.1 '((0 0 8 6 2 7 0 0 9)
                 (0 0 0 5 0 0 0 0 0)
                 (0 3 0 0 9 0 0 0 0)
                 (0 0 6 9 0 0 3 0 2)
                 (0 0 0 0 0 0 9 5 0)
                 (1 0 0 8 0 0 0 0 0)
                 (0 0 0 0 5 2 0 6 3)
                 (4 0 0 0 8 0 0 0 0)
                 (0 0 0 3 0 0 2 4 0)))
;cpu time: 12 real time: 12 gc time: 5
;((5 1 8 6 2 7 4 3 9)
; (2 6 9 5 4 3 7 8 1)
; (7 3 4 1 9 8 5 2 6)
; (8 5 6 9 7 4 3 1 2)
; (3 4 7 2 6 1 9 5 8)
; (1 9 2 8 3 5 6 7 4)
; (9 7 1 4 5 2 8 6 3)
; (4 2 3 7 8 6 1 9 5)
; (6 8 5 3 1 9 2 4 7))

(define hard.2 '((0 0 5 0 7 0 0 0 0)
                 (0 0 6 0 0 9 0 0 0)
                 (0 9 0 0 5 0 0 0 0)
                 (0 7 9 0 0 2 5 0 0)
                 (0 0 0 0 6 0 9 1 0)
                 (0 0 0 5 0 8 4 0 0)
                 (0 0 0 0 0 0 0 0 3)
                 (0 5 0 6 0 0 0 0 1)
                 (9 1 0 4 0 7 0 0 5)))
;cpu time: 15 real time: 15 gc time: 0
;((3 4 5 8 7 1 6 2 9)
; (7 2 6 3 4 9 1 5 8)
; (8 9 1 2 5 6 3 7 4)
; (4 7 9 1 3 2 5 8 6)
; (5 3 8 7 6 4 9 1 2)
; (1 6 2 5 9 8 4 3 7)
; (6 8 7 9 1 5 2 4 3)
; (2 5 4 6 8 3 7 9 1)
; (9 1 3 4 2 7 8 6 5))

(define very-hard.1 '((0 5 0 0 0 8 2 6 9)
                      (0 0 2 0 4 3 0 0 0)
                      (0 0 9 0 0 0 0 0 0)
                      (0 0 7 0 0 0 0 0 0)
                      (0 0 0 0 9 0 0 4 0)
                      (5 0 3 0 0 0 0 9 0)
                      (0 0 0 0 2 4 6 0 5)
                      (6 0 0 0 0 0 0 0 3)
                      (0 4 0 0 8 0 0 0 0)))
;cpu time: 34 real time: 35 gc time: 0
;((3 5 4 1 7 8 2 6 9)
; (7 6 2 9 4 3 5 1 8)
; (8 1 9 6 5 2 7 3 4)
; (4 9 7 2 3 1 8 5 6)
; (1 2 6 8 9 5 3 4 7)
; (5 8 3 4 6 7 1 9 2)
; (9 3 1 7 2 4 6 8 5)
; (6 7 8 5 1 9 4 2 3)
; (2 4 5 3 8 6 9 7 1))

(define very-hard.2 '((0 4 0 0 0 0 0 0 0)
                      (0 0 6 0 1 0 4 0 0)
                      (0 0 1 0 3 7 0 0 0)
                      (0 0 0 0 0 8 0 1 0)
                      (0 6 0 7 0 0 0 5 0)
                      (0 0 8 0 9 0 0 7 0)
                      (0 5 0 1 0 0 8 6 0)
                      (0 0 0 3 0 0 0 9 0)
                      (9 0 0 0 0 0 2 0 0)))
;cpu time: 21 real time: 21 gc time: 0
;((3 4 5 9 6 2 7 8 1)
; (7 2 6 8 1 5 4 3 9)
; (8 9 1 4 3 7 5 2 6)
; (4 7 9 6 5 8 3 1 2)
; (1 6 2 7 4 3 9 5 8)
; (5 3 8 2 9 1 6 7 4)
; (2 5 4 1 7 9 8 6 3)
; (6 8 7 3 2 4 1 9 5)
; (9 1 3 5 8 6 2 4 7))

(define extremely-hard.1 '((0 1 0 0 0 2 5 4 0)
                           (0 9 8 0 0 0 0 0 0)
                           (0 0 0 0 0 0 0 0 0)
                           (6 0 7 0 0 0 3 0 0)
                           (5 0 0 2 0 0 0 0 0)
                           (0 0 0 9 0 0 0 0 0)
                           (0 0 0 0 6 0 0 9 8)
                           (0 0 0 0 3 0 0 0 0)
                           (7 0 0 0 0 0 0 0 0)))
;cpu time: 58 real time: 60 gc time: 1
;((3 1 6 8 9 2 5 4 7)
; (4 9 8 3 5 7 1 6 2)
; (2 7 5 6 4 1 9 8 3)
; (6 2 7 4 8 5 3 1 9)
; (5 4 9 2 1 3 8 7 6)
; (8 3 1 9 7 6 4 2 5)
; (1 5 3 7 6 4 2 9 8)
; (9 6 2 1 3 8 7 5 4)
; (7 8 4 5 2 9 6 3 1))

(define extremely-hard.2 '((0 0 0 1 0 2 0 3 0)
                           (8 0 0 7 0 0 0 0 0)
                           (4 0 0 0 0 0 9 0 0)
                           (0 1 0 3 0 0 0 0 0)
                           (0 0 0 0 6 0 4 0 0)
                           (0 0 0 0 0 0 0 0 0)
                           (6 0 9 0 4 0 0 0 0)
                           (0 0 0 0 0 0 0 7 1)
                           (0 0 0 0 5 0 0 0 0)))
;cpu time: 23 real time: 24 gc time: 0
;((7 9 6 1 8 2 5 3 4)
; (8 5 3 7 9 4 1 2 6)
; (4 2 1 5 3 6 9 8 7)
; (9 1 4 3 7 5 2 6 8)
; (3 8 7 2 6 9 4 1 5)
; (2 6 5 4 1 8 7 9 3)
; (6 7 9 8 4 1 3 5 2)
; (5 4 8 9 2 3 6 7 1)
; (1 3 2 6 5 7 8 4 9))

;; A "hard" puzzle from: https://github.com/frankmcsherry/blog/blob/master/posts/2020-06-06.md
;; The blog implementation solves this puzzle in 44.7ms.
;; Our SAT solver is about 15x faster in this case.
(define not-too-hard '((0 0 1 2 0 3 4 0 0)
                       (0 0 0 6 0 7 0 0 0)
                       (5 0 0 0 0 0 0 0 3)
                       (3 7 0 0 0 0 0 8 1)
                       (0 0 0 0 0 0 0 0 0)
                       (6 2 0 0 0 0 0 3 7)
                       (1 0 0 0 0 0 0 0 8)
                       (0 0 0 8 0 5 0 0 0)
                       (0 0 6 4 0 2 5 0 0)))
;cpu time: 3 real time: 3 gc time: 0
;((7 8 1 2 5 3 4 9 6)
; (2 4 3 6 9 7 8 1 5)
; (5 6 9 1 4 8 7 2 3)
; (3 7 5 9 2 4 6 8 1)
; (9 1 8 3 7 6 2 5 4)
; (6 2 4 5 8 1 9 3 7)
; (1 5 2 7 6 9 3 4 8)
; (4 9 7 8 3 5 1 6 2)
; (8 3 6 4 1 2 5 7 9))

(define board.empty '((0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)
                      (0 0 0 0 0 0 0 0 0)))

(for-each (lambda (board) (pretty-write (time (sudoku-solve1 board))))
          (list
           really-easy.0
           really-easy.1
           really-easy.2
           really-easy.3
           really-easy.4
           easy.1
           easy.2
           medium.1
           medium.2
           grid.50
           hard.1
           hard.2
           very-hard.1
           very-hard.2
           extremely-hard.1
           extremely-hard.2
           not-too-hard
           ))

(for-each (lambda (board) (pretty-write (time (s-take 20 (sudoku-solve board)))))
          (list
           really-easy.0
           really-easy.1
           really-easy.2
           really-easy.3
           really-easy.4
           easy.1
           easy.2
           medium.1
           medium.2
           grid.50
           hard.1
           hard.2
           very-hard.1
           very-hard.2
           extremely-hard.1
           extremely-hard.2
           not-too-hard
           ))

;; The naive SAT solvers still have trouble even with the direct problem representation.

;; 2-watching solver with the direct problem representation:
;cpu time: 1 real time: 1 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 4 real time: 4 gc time: 1
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 2 real time: 2 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 3 real time: 3 gc time: 0
;((4 6 9 8 3 2 1 5 7)
; (7 3 5 1 9 6 2 8 4)
; (2 8 1 7 4 5 3 9 6)
; (9 2 6 3 7 8 4 1 5)
; (1 5 8 4 2 9 7 6 3)
; (3 4 7 5 6 1 9 2 8)
; (5 1 3 9 8 4 6 7 2)
; (6 9 4 2 5 7 8 3 1)
; (8 7 2 6 1 3 5 4 9))
;cpu time: 4 real time: 4 gc time: 1
;((8 3 2 6 4 9 1 5 7)
; (7 4 5 8 2 1 3 9 6)
; (1 9 6 3 7 5 2 8 4)
; (3 7 8 2 9 6 4 1 5)
; (4 2 9 5 1 8 7 6 3)
; (5 6 1 4 3 7 9 2 8)
; (6 1 3 7 8 2 5 4 9)
; (2 5 7 9 6 4 8 3 1)
; (9 8 4 1 5 3 6 7 2))
;cpu time: 2 real time: 3 gc time: 0
;((3 4 2 6 8 7 9 1 5)
; (1 9 7 2 5 4 6 8 3)
; (5 6 8 9 1 3 4 2 7)
; (9 2 6 3 4 5 8 7 1)
; (8 5 1 7 2 6 3 4 9)
; (4 7 3 8 9 1 2 5 6)
; (6 8 5 4 7 9 1 3 2)
; (7 3 4 1 6 2 5 9 8)
; (2 1 9 5 3 8 7 6 4))
;cpu time: 3 real time: 3 gc time: 0
;((7 9 4 1 3 2 6 8 5)
; (6 2 1 5 9 8 7 3 4)
; (3 8 5 7 6 4 2 1 9)
; (1 3 9 4 2 7 5 6 8)
; (8 7 6 9 1 5 3 4 2)
; (5 4 2 6 8 3 1 9 7)
; (4 5 3 8 7 1 9 2 6)
; (2 6 7 3 4 9 8 5 1)
; (9 1 8 2 5 6 4 7 3))
;cpu time: 4 real time: 5 gc time: 0
;((3 5 1 2 8 6 4 9 7)
; (4 9 2 1 5 7 6 3 8)
; (7 8 6 9 3 4 5 1 2)
; (2 7 5 4 6 9 1 8 3)
; (9 3 8 5 2 1 7 6 4)
; (6 1 4 8 7 3 2 5 9)
; (8 2 9 6 4 5 3 7 1)
; (1 6 3 7 9 2 8 4 5)
; (5 4 7 3 1 8 9 2 6))
;cpu time: 12 real time: 12 gc time: 5
;((5 1 8 6 2 7 4 3 9)
; (2 6 9 5 4 3 7 8 1)
; (7 3 4 1 9 8 5 2 6)
; (8 5 6 9 7 4 3 1 2)
; (3 4 7 2 6 1 9 5 8)
; (1 9 2 8 3 5 6 7 4)
; (9 7 1 4 5 2 8 6 3)
; (4 2 3 7 8 6 1 9 5)
; (6 8 5 3 1 9 2 4 7))
;cpu time: 15 real time: 15 gc time: 0
;((3 4 5 8 7 1 6 2 9)
; (7 2 6 3 4 9 1 5 8)
; (8 9 1 2 5 6 3 7 4)
; (4 7 9 1 3 2 5 8 6)
; (5 3 8 7 6 4 9 1 2)
; (1 6 2 5 9 8 4 3 7)
; (6 8 7 9 1 5 2 4 3)
; (2 5 4 6 8 3 7 9 1)
; (9 1 3 4 2 7 8 6 5))
;cpu time: 34 real time: 35 gc time: 0
;((3 5 4 1 7 8 2 6 9)
; (7 6 2 9 4 3 5 1 8)
; (8 1 9 6 5 2 7 3 4)
; (4 9 7 2 3 1 8 5 6)
; (1 2 6 8 9 5 3 4 7)
; (5 8 3 4 6 7 1 9 2)
; (9 3 1 7 2 4 6 8 5)
; (6 7 8 5 1 9 4 2 3)
; (2 4 5 3 8 6 9 7 1))
;cpu time: 21 real time: 21 gc time: 0
;((3 4 5 9 6 2 7 8 1)
; (7 2 6 8 1 5 4 3 9)
; (8 9 1 4 3 7 5 2 6)
; (4 7 9 6 5 8 3 1 2)
; (1 6 2 7 4 3 9 5 8)
; (5 3 8 2 9 1 6 7 4)
; (2 5 4 1 7 9 8 6 3)
; (6 8 7 3 2 4 1 9 5)
; (9 1 3 5 8 6 2 4 7))
;cpu time: 58 real time: 60 gc time: 1
;((3 1 6 8 9 2 5 4 7)
; (4 9 8 3 5 7 1 6 2)
; (2 7 5 6 4 1 9 8 3)
; (6 2 7 4 8 5 3 1 9)
; (5 4 9 2 1 3 8 7 6)
; (8 3 1 9 7 6 4 2 5)
; (1 5 3 7 6 4 2 9 8)
; (9 6 2 1 3 8 7 5 4)
; (7 8 4 5 2 9 6 3 1))
;cpu time: 23 real time: 24 gc time: 0
;((7 9 6 1 8 2 5 3 4)
; (8 5 3 7 9 4 1 2 6)
; (4 2 1 5 3 6 9 8 7)
; (9 1 4 3 7 5 2 6 8)
; (3 8 7 2 6 9 4 1 5)
; (2 6 5 4 1 8 7 9 3)
; (6 7 9 8 4 1 3 5 2)
; (5 4 8 9 2 3 6 7 1)
; (1 3 2 6 5 7 8 4 9))
;cpu time: 3 real time: 3 gc time: 0
;((7 8 1 2 5 3 4 9 6)
; (2 4 3 6 9 7 8 1 5)
; (5 6 9 1 4 8 7 2 3)
; (3 7 5 9 2 4 6 8 1)
; (9 1 8 3 7 6 2 5 4)
; (6 2 4 5 8 1 9 3 7)
; (1 5 2 7 6 9 3 4 8)
; (4 9 7 8 3 5 1 6 2)
; (8 3 6 4 1 2 5 7 9))
